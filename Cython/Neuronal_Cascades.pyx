{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "import random\n",
    "import matplotlib.pyplot as plt\n",
    "from sklearn.metrics.pairwise import euclidean_distances\n",
    "from scipy.spatial import distance\n",
    "from math import sqrt\n",
    "import gudhi"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "cpdef class neuron:\n",
    "    \n",
    "    cdef public int name, state, memory, rest\n",
    "    cdef public float threshold\n",
    "    cdef public list history\n",
    "    \n",
    "    def __init__(self, int name, int state = False, int memory = 0, int rest = 0, float threshold = 0.1):\n",
    "        self.name = name\n",
    "        self.state = state\n",
    "        self.memory = memory\n",
    "        self.rest = rest\n",
    "        self.threshold = threshold\n",
    "        \n",
    "        self.refresh_history()\n",
    "        \n",
    "    def refresh_history(self):\n",
    "        self.history = []"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "cimport numpy\n",
    "cimport cython\n",
    "import numpy as np\n",
    "import random\n",
    "import matplotlib.pyplot as plt\n",
    "from sklearn.metrics.pairwise import euclidean_distances\n",
    "from scipy.spatial import distance\n",
    "from math import sqrt\n",
    "import gudhi\n",
    "\n",
    "DTYPE = np.int64\n",
    "\n",
    "ctypedef fused A:\n",
    "    int\n",
    "    long\n",
    "ctypedef fused link_list:\n",
    "    int\n",
    "    long\n",
    "ctypedef fused stubs:\n",
    "    int\n",
    "    long\n",
    "\n",
    "ctypedef numpy.int_t DTYPE_t\n",
    "\n",
    "\n",
    "cdef class Geometric_Brain_Network:\n",
    "    \n",
    "    cdef int N, GD, nGD\n",
    "    cdef str manifold, text\n",
    "    cdef public list nodes\n",
    "    cdef public numpy.ndarray A\n",
    "    cdef public int time\n",
    "    \n",
    "    def __init__(self, int size, int geometric_degree = 1, int nongeometric_degree = 0, str manifold = 'Ring'):\n",
    "        \n",
    "        self.N = size  \n",
    "        self.GD = geometric_degree\n",
    "        self.nGD = nongeometric_degree\n",
    "        self.manifold = manifold\n",
    "        self.text = '%s Network on %d nodes'%(self.manifold, self.N)\n",
    "        A = np.zeros((self.N,self.N), dtype = np.int64)\n",
    "        \n",
    "        self.make_geometric(A)\n",
    "        \n",
    "        if self.nGD > 0: self.add_noise_to_geometric()\n",
    "        \n",
    "    def get_neurons(self, list neurons):\n",
    "\n",
    "        if len(neurons) != self.N: \n",
    "            raise ValueError('Size of the network and the number of neurons should match')\n",
    "        \n",
    "        self.nodes = neurons\n",
    "    \n",
    "    def make_geometric(self, numpy.ndarray[DTYPE_t, ndim=2] A):\n",
    "        \n",
    "        cdef int gd, v\n",
    "        cdef Py_ssize_t u, i\n",
    "        \n",
    "        self.A = A\n",
    "        \n",
    "        if self.manifold == 'Ring':\n",
    "            \n",
    "            #if self.GD >= int(self.N)-1: \n",
    "                #raise InputError('Geometric Degree cannot exceed the half of the size of the network.')\n",
    "            #elif self.GD<1 or self.GD%2 == 1:\n",
    "                #raise InputError('Geometric Degree should be an even positive integer.')\n",
    "            \n",
    "            gd = int(self.GD/2)\n",
    "            for u in range(self.N):\n",
    "                for i in range(1, gd + 1):\n",
    "                    #from left\n",
    "                    if u + i >= self.N: \n",
    "                        v = u + i - self.N\n",
    "                    else: v = u + i\n",
    "                    self.A[u,v] = True\n",
    "                    #from right\n",
    "                    if u - i < 0: \n",
    "                        v = self.N + u - i\n",
    "                    else: v = u - i\n",
    "                    self.A[u,v] = True\n",
    "            self.text = self.text + ' w/ GD %d'%(self.GD)\n",
    "    \n",
    "    def add_noise_to_geometric(self):#, numpy.ndarray[DTYPE_t, ndim=2] A):\n",
    "\n",
    "        cdef Py_ssize_t i, m, n, k\n",
    "        cdef int M, flag_2, flag_1, node_A, node_B, count, rand1, rand2\n",
    "        cdef numpy.ndarray nongeo, index\n",
    "        cdef numpy.ndarray link_list\n",
    "        cdef numpy.ndarray stubs \n",
    "        \n",
    "        M = int(self.N * self.nGD)\n",
    "        \n",
    "        #if M%2 == 1: raise ValueError('Try providing an even non-geometric degree')\n",
    "            \n",
    "        flag_2 = True\n",
    "            \n",
    "        while flag_2:\n",
    "            flag_2 = False\n",
    "            #build stubs\n",
    "            stubs = np.zeros((M), dtype = DTYPE)\n",
    "            nongeo = np.ones((self.nGD), dtype = np.int64)\n",
    "            for i in range(self.N):\n",
    "                index = (i*self.nGD) + np.arange(self.nGD, dtype = np.int64)\n",
    "                stubs[index[0]:index[-1]+1] = (i) * np.asarray(nongeo)\n",
    "                    \n",
    "            #build undirected link list\n",
    "            link_list = np.zeros((int(M/2),2), dtype = DTYPE)\n",
    "            for m in range(int(M/2)):\n",
    "                flag_1 = True # turn on flag to enter while loop\n",
    "                count = 0\n",
    "                while flag_1:\n",
    "                    flag_1 = False #turn off flag to exit while loop\n",
    "                    rand1 = random.randint(0, len(stubs)-1)\n",
    "                    rand2 = random.randint(0, len(stubs)-1)\n",
    "                    \n",
    "                    node_A = int(stubs[rand1])\n",
    "                    node_B = int(stubs[rand2])\n",
    "                                            \n",
    "                    if node_A == node_B: flag_1 = True\n",
    "                    \n",
    "                    for n in range(m):\n",
    "                        if link_list[n,0] == node_A and link_list[n,1] == node_B:\n",
    "                            flag_1 = True\n",
    "                        if link_list[n,0] == node_B and link_list[n,1] == node_A:\n",
    "                            flag_1 = True\n",
    "                        if self.A[node_A][node_B] == 1 or self.A[node_B][node_A] == 1:\n",
    "                            flag_1 = True\n",
    "                            \n",
    "                    count = count +1\n",
    "                    \n",
    "                    if count > M: flag_2 = True ; break\n",
    "                        \n",
    "                #make link       \n",
    "                link_list[m,0] = node_A\n",
    "                link_list[m,1] = node_B\n",
    "                \n",
    "                #remove stubs from list\n",
    "                stubs = np.delete(stubs,[rand1,rand2])\n",
    "        \n",
    "        #build network\n",
    "        for k in range(int(M/2)):\n",
    "            self.A[link_list[k,0],link_list[k,1]] = True\n",
    "            self.A[link_list[k,1],link_list[k,0]] = True\n",
    "        self.text = self.text + ' and nGD %d'%self.nGD\n",
    "    \n",
    "    def neighbors(self, int node_id):\n",
    "        \n",
    "        cdef numpy.ndarray nhood\n",
    "        \n",
    "        nhood = np.nonzero(self.A[node_id])[0]\n",
    "\n",
    "        return(nhood)\n",
    "    \n",
    "    def neighbor_input(self, int node_id):\n",
    "        cdef numpy.ndarray nbhood\n",
    "        cdef Py_ssize_t i\n",
    "        cdef int e\n",
    "        cdef list active_hood\n",
    "        cdef float F\n",
    "\n",
    "        nbhood = self.neighbors(node_id)\n",
    "        active_hood = []\n",
    "        \n",
    "        for i,e in enumerate(nbhood):\n",
    "            if self.nodes[e].state == 1:\n",
    "                active_hood.append(e)\n",
    "                \n",
    "        F = len(active_hood)/len(nbhood) - self.nodes[node_id].threshold\n",
    "        \n",
    "        return(F)\n",
    "    \n",
    "    def sigmoid(self, int node_id, int C):\n",
    "        \n",
    "        cdef float F, Z\n",
    "\n",
    "        F = self.neighbor_input(node_id)\n",
    "        Z = 1/(1+np.exp(-C*F))\n",
    "        \n",
    "        return(Z)\n",
    "    \n",
    "    def update_history(self, int node_id, int C):\n",
    "        cdef float rand\n",
    "        cdef Py_ssize_t i,j\n",
    "        \n",
    "        rand = random.uniform(0,1)\n",
    "        \n",
    "        if rand <= self.sigmoid(node_id, C):\n",
    "            \n",
    "            for i in range(self.nodes[node_id].memory + 1):\n",
    "                self.nodes[node_id].history.append(1)\n",
    "                \n",
    "            for j in range(self.nodes[node_id].rest):\n",
    "                self.nodes[node_id].history.append(-1)\n",
    "                \n",
    "            self.nodes[node_id].history.append(0)\n",
    "            \n",
    "        else:\n",
    "            self.nodes[node_id].history.append(0)\n",
    "    \n",
    "    def update_states(self):\n",
    "        cdef list excited, ready_to_fire, rest\n",
    "        \n",
    "        cdef object node\n",
    "        \n",
    "        excited = []\n",
    "        ready_to_fire = []\n",
    "        rest = []\n",
    "        \n",
    "        for node in self.nodes:\n",
    "            \n",
    "            node.state = int(node.history[self.time])\n",
    "                \n",
    "            if node.state == 1:\n",
    "                excited.append(node.name)\n",
    "            elif node.state == 0:\n",
    "                ready_to_fire.append(node.name)\n",
    "            else: rest.append(node.name)\n",
    "                \n",
    "        return(excited, ready_to_fire, rest)\n",
    "                \n",
    "    def initial_spread(self, int seed):\n",
    "        cdef Py_ssize_t i, j, k\n",
    "        cdef set excited_nodes_set, all_nodes\n",
    "        cdef int node1, node2\n",
    "        cdef list excited_nodes_list\n",
    "\n",
    "        all_nodes = set([k for k in range(self.N)])\n",
    "        excited_nodes_list = list(self.neighbors(seed))\n",
    "        excited_nodes_set = set(excited_nodes_list)\n",
    "        \n",
    "        for node1 in excited_nodes_list:\n",
    "            for i in range(self.nodes[node1].memory + 1):\n",
    "                self.nodes[node1].history.append(1)\n",
    "            for j in range(self.nodes[node1].rest):\n",
    "                self.nodes[node1].history.append(-1)\n",
    "                \n",
    "            self.nodes[node1].history.append(0)\n",
    "            \n",
    "        for node2 in list(all_nodes.difference(excited_nodes_set)):\n",
    "            self.nodes[node2].history.append(0)\n",
    "            \n",
    "    def refresh(self):\n",
    "        cdef int tolerance\n",
    "        cdef object node\n",
    "        \n",
    "        self.time = 0\n",
    "        tolerance = 0\n",
    "        \n",
    "        for node in self.nodes:\n",
    "            node.refresh_history()\n",
    "            \n",
    "        return(tolerance)\n",
    "    \n",
    "    def run_dynamic(self, int seed, int TIME, int C):\n",
    "        \n",
    "        cdef numpy.ndarray activation_times\n",
    "        cdef list size_of_contagion, excited_nodes, ready_to_fire_nodes, resting_nodes\n",
    "        cdef int node, tolerance\n",
    "        cdef Py_ssize_t i\n",
    "\n",
    "        tolerance = self.refresh()\n",
    "        activation_times = np.ones(self.N, dtype = np.int64)*TIME\n",
    "        size_of_contagion = [int(0)]\n",
    "        self.initial_spread(seed)\n",
    "        excited_nodes, ready_to_fire_nodes, resting_nodes = self.update_states()\n",
    "        \n",
    "        self.time = 1\n",
    "        \n",
    "        while self.time < TIME and 0 < len(excited_nodes) and np.any(activation_times==TIME):\n",
    "            size_of_contagion.append(len(excited_nodes))\n",
    "            \n",
    "            activation_times[excited_nodes] = np.minimum(activation_times[excited_nodes], \n",
    "                                                         np.array([self.time]*len(excited_nodes)))\n",
    "            \n",
    "            for node in ready_to_fire_nodes: \n",
    "                self.update_history(node, C)\n",
    "            \n",
    "            excited_nodes, ready_to_fire_nodes, resting_nodes = self.update_states()\n",
    "            \n",
    "            self.time = self.time + 1\n",
    "        \n",
    "        if len(size_of_contagion) < TIME:\n",
    "            for i in range(len(size_of_contagion), TIME):\n",
    "                size_of_contagion.append(size_of_contagion[-1])\n",
    "\n",
    "        return(activation_times, np.array(size_of_contagion))\n",
    "    \n",
    "    def stack_histories(self, int TIME):\n",
    "        cdef object node\n",
    "        cdef list states\n",
    "        cdef numpy.ndarray all_history\n",
    "        cdef Py_ssize_t i\n",
    "        \n",
    "        for node in self.nodes:\n",
    "            if len(node.history) < TIME:\n",
    "                node.history = node.history + [node.history[-1] for i in range(len(node.history), TIME)]\n",
    "            node.history = node.history[:TIME]\n",
    "        states = [node.history for node in self.nodes]\n",
    "        all_history = np.vstack(states)\n",
    "        return(all_history)\n",
    "    \n",
    "    def average_over_trials(self, int seed, int TIME, int C, int trials):\n",
    "        \n",
    "        cdef numpy.ndarray first_excitation_times, size_of_contagion, first_exct, contagion_size\n",
    "        cdef numpy.ndarray average_excitation_times, average_contagion_size\n",
    "        cdef Py_ssize_t i\n",
    "\n",
    "        first_excitation_times = np.zeros((self.N, trials), dtype = np.int64)\n",
    "        size_of_contagion = np.zeros((TIME, trials), dtype = np.int64)\n",
    "        \n",
    "        for i in range(trials):\n",
    "            first_exct, contagion_size = self.run_dynamic(seed, TIME, C)\n",
    "                                                            \n",
    "            first_excitation_times[:,i] = first_exct\n",
    "            size_of_contagion[:,i] = contagion_size\n",
    "        \n",
    "        average_excitation_times = np.mean(first_excitation_times, axis = 1)\n",
    "        average_contagion_size = np.mean(size_of_contagion, axis = 1)\n",
    "        \n",
    "        return(average_excitation_times, average_contagion_size)\n",
    "    \n",
    "    def make_distance_matrix(self, int TIME, int C, int trials):\n",
    "        cdef numpy.ndarray D,Q, distance_matrix\n",
    "        cdef Py_ssize_t seed\n",
    "\n",
    "        D = np.zeros((self.N, self.N), dtype = np.int64)\n",
    "        Q = np.zeros((self.N, TIME), dtype = np.int64)\n",
    "        \n",
    "        for seed in range(self.N):\n",
    "            D[seed], Q[seed,:] = self.average_over_trials(seed, TIME, C, trials)\n",
    "        \n",
    "        distance_matrix = euclidean_distances(D.T)\n",
    "        \n",
    "        return(distance_matrix, Q)\n",
    "    \n",
    "    def compute_persistence(self, numpy.ndarray[double, ndim = 2] distances, int dimension = 2, int spy = False):\n",
    "        \n",
    "        cdef object rips_complex\n",
    "        cdef list persistence, oned_holes\n",
    "        cdef Py_ssize_t i\n",
    "        cdef numpy.ndarray one_d_holes, persistence_life_times\n",
    "        cdef float Delta_min, Delta_max\n",
    "        \n",
    "        rips_complex = gudhi.RipsComplex(distance_matrix = distances/np.max(distances), max_edge_length = 1)\n",
    "        simplex_tree = rips_complex.create_simplex_tree(max_dimension = dimension)\n",
    "        persistence = simplex_tree.persistence(min_persistence = 0.0)\n",
    "        \n",
    "        if spy: \n",
    "            gudhi.plot_persistence_diagram(persistence)\n",
    "\n",
    "        oned_holes = [(0,0)]\n",
    "        for i in range(len(persistence)):\n",
    "            if persistence[i][0] == int(dimension-1):\n",
    "                oned_holes.append(persistence[i][1])\n",
    "        one_d_holes = np.array(oned_holes)\n",
    "        persistence_life_times = one_d_holes[:,1]-one_d_holes[:,0]\n",
    "        Delta_min = np.sort(persistence_life_times)[-1]-np.sort(persistence_life_times)[-2]\n",
    "        Delta_max = np.sort(persistence_life_times)[-1]-np.sort(persistence_life_times)[1]\n",
    "        return(Delta_min, Delta_max)\n",
    "    \n",
    "    def display_comm_sizes(self, list Q, list labels, int TIME, int C, int trials, int memory, int rest):\n",
    "        \n",
    "        cdef list argmaxs, colors\n",
    "        cdef numpy.ndarray Q_mean, X\n",
    "        cdef Py_ssize_t i, j\n",
    "        cdef object fig, ax\n",
    "        \n",
    "        argmaxs = []\n",
    "        colors = ['violet', 'green', 'black', 'lime', 'blue', 'orange', 'brown', 'yellow', 'red', 'turquoise', \n",
    "                  'purple']\n",
    "    \n",
    "        for j in range(len(Q)):\n",
    "            Q_mean = np.mean(Q[j], axis = 0)\n",
    "            argmaxs.append(np.argmax(Q_mean))\n",
    "        \n",
    "        X = np.linspace(0, int(np.min([TIME-2,np.max(argmaxs)])+1), int(np.min([TIME-2,np.max(argmaxs)])+2))\n",
    "        \n",
    "        fig,ax = plt.subplots(1,1, figsize = (12,8))\n",
    "    \n",
    "        for i in range(len(Q)):\n",
    "            Q_mean = np.mean(Q[i], axis = 0)\n",
    "        \n",
    "            if i == 0: ax.plot(Q_mean[:int(np.min([TIME-2,np.max(argmaxs)])+2)], \n",
    "                               label = 'threshold = %.2f'%labels[i], \n",
    "                               linestyle = 'dashed', \n",
    "                               marker = 'v',\n",
    "                               color = colors[i%11])\n",
    "            \n",
    "            else: ax.plot(Q_mean[:int(np.min([TIME-2,np.max(argmaxs)])+2)], \n",
    "                          label = 'threshold = %.2f'%labels[i], \n",
    "                          marker = 'v', \n",
    "                          color = colors[i%11])\n",
    "            \n",
    "            ax.fill_between(X, \n",
    "                            np.max(Q[i], axis = 0)[:int(np.min([TIME-2,np.max(argmaxs)])+2)], \n",
    "                            np.min(Q[i], axis = 0)[:int(np.min([TIME-2,np.max(argmaxs)])+2)], \n",
    "                            alpha = 0.2, color = colors[i%11])\n",
    "            \n",
    "        ax.set_title('%s, T = %d, C = %d, trials = %d,  MEMORY = %d, REST = %d'%(self.text, TIME, C, trials, memory, rest), fontsize = 25)\n",
    "        ax.set_xlabel('Time', fontsize = 20)\n",
    "        ax.set_ylabel('Number of Active Nodes', fontsize = 20)\n",
    "        ax.legend()\n",
    "        return(fig,ax)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.6"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 4
}
